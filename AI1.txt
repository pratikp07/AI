#include<iostream>
#include<list>
#include<map>
#include<queue>

using namespace std;

class Graph{
    public:

    map<int, list<int>> adjList;
    map<int, bool> visited;
    queue<int> q;
    
    //Copy Constructor
    // Graph(const Graph &g){
    // }
    
    void addEdge(int src, int dest){
        adjList[src].push_back(dest);
        adjList[dest].push_back(src);
    }

    void DFS(int node){
        //Mark Node as visited
        visited[node] = true;
        //Print Node
        cout << node << " ";
        //Vist its neighbours and recurse
        for(int i : adjList[node]){
            //If node is not visited
            if(!visited[i]) DFS(i);
        }
    }

    void BFS(){
        //Recurse until queue is empty
        if(q.empty()) return;
        //Pop and assign 1st node in queue
        int node = q.front();
        q.pop();
        //Print node
        cout << node << " ";
        for(int i : adjList[node]){
            //If neighbour is not visited add it to queue
            if(!visited[i]){
                visited[i] = true;
                q.push(i);
            }
        }
        BFS();
    }
};



int main(){
    Graph g;
    g.addEdge(0,1);
    g.addEdge(0,2);
    g.addEdge(0,3);
    g.addEdge(1,3);
    g.addEdge(3,4);
    g.addEdge(4,5);
    g.addEdge(2,6);
    
    int ch;
    cout << "Enter 0 to perform DFS and 1 to perform BFS: ";
    cin >> ch;
    if(!ch){
        cout << "DFS on the given graph is :";
        g.DFS(0);
    }
    else{
        cout << "BFS on the given graph is: ";
        g.q.push(0);
        g.visited[0] = true;
        g.BFS();    
    }
    return 0;
}

/*
This code defines a C++ program to perform Depth-First Search (DFS) and Breadth-First Search (BFS) on a graph.
1. **Header Files**: The program includes necessary header files such as `<iostream>`, `<list>`, `<map>`, and `<queue>`.

2. **Graph Class**: It defines a class named `Graph`. Inside this class, there are:

    - `adjList`: This is a map where the keys represent graph nodes, and the values represent lists of adjacent nodes.
    
    - `visited`: This is a map to keep track of visited nodes during traversal.
    
    - `q`: This is a queue used for BFS traversal.

3. **`addEdge` Function**: This function adds an edge between two given nodes by updating the adjacency list.

4. **DFS Function**: This function performs Depth-First Search. It recursively visits each node and its neighbors in a depth-first manner, marking visited nodes along the way.

5. **BFS Function**: This function performs Breadth-First Search. It starts by adding the initial node to the queue, then iteratively visits its neighbors layer by layer, marking visited nodes and enqueueing unvisited neighbors.

6. **`main` Function**: In the `main` function:

    - It creates an instance of the `Graph` class.
    
    - It adds edges to the graph.
    
    - It prompts the user to choose between DFS and BFS.
    
    - If the user selects DFS, it calls the `DFS` function starting from node 0.
    
    - If the user selects BFS, it initializes the queue with node 0, marks it as visited, and calls the `BFS` function.



Both Breadth-First Search (BFS) and Depth-First Search (DFS) are algorithms used to traverse or search a graph, but they do so in different ways. Here are the key differences between BFS and DFS:

1. **Order of traversal**:
   - BFS: Traverses the graph level by level, starting from the source node. It explores all the neighboring nodes of the current level before moving to the next level.
   - DFS: Traverses the graph depth by depth, exploring as far as possible along each branch before backtracking.

2. **Data structure**:
   - BFS: Uses a queue to store the nodes to be visited. It follows the First In First Out (FIFO) principle, which ensures that nodes closer to the source are visited earlier.
   - DFS: Uses a stack (or recursion) to store the nodes to be visited. It follows the Last In First Out (LIFO) principle, which means that nodes closer to the source are visited later.

3. **Completeness**:
   - BFS: Guarantees finding the shortest path between two nodes in an unweighted graph if it exists.
   - DFS: May not find the shortest path between two nodes, especially in an unweighted graph.

4. **Space complexity**:
   - BFS: Requires more memory as it needs to store all the nodes at each level in the queue.
   - DFS: Typically requires less memory compared to BFS, especially if implemented using recursion, as it only needs to store the path from the source node to the current node.

5. **Time complexity**:
   - BFS: Typically has a higher time complexity than DFS due to its need to explore all neighbors at each level.
   - DFS: Typically has a lower time complexity than BFS, especially if the graph is sparse or has a deep branching factor.

6. **Applications**:
   - BFS: Useful for finding the shortest path, solving puzzles (such as maze solving), and detecting connected components in a graph.
   - DFS: Useful for topological sorting, cycle detection, and traversing through trees.

In summary, BFS is more suitable for finding the shortest path in unweighted graphs, while DFS is useful for exploring deeper into a graph and solving problems related to traversal. The choice between BFS and DFS depends on the specific requirements of the problem and the characteristics of the graph.
*/